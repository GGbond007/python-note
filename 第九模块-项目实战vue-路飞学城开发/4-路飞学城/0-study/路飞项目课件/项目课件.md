项目课件

课件地址

https://www.cnblogs.com/GGGG-XXXX/articles/9907408.html



我们之前学习过了Vue也学习过了DRF，现在开始我们要开始写前后端分离的项目了~~~

写前后端分离的项目之前，还有两个知识点给大家补充一下~~

-   [跨域](https://www.cnblogs.com/GGGG-XXXX/articles/9893381.html)
-   [ContentType组件](https://www.cnblogs.com/GGGG-XXXX/articles/9697458.html)
-   [课程模块](https://www.cnblogs.com/GGGG-XXXX/articles/9913643.html)
-   [登录认证模块](https://www.cnblogs.com/GGGG-XXXX/articles/9922552.html)
-   [Redis](https://www.cnblogs.com/GGGG-XXXX/articles/9289135.html)
-   [购物模块之购物车](https://www.cnblogs.com/GGGG-XXXX/articles/9932334.html)
-   [购物模块之结算中心](https://www.cnblogs.com/GGGG-XXXX/articles/10103162.html)
-   购物模块之支付中心
-   三方服务之微信模板消息推送
-   [三方服务之支付宝支付](https://www.cnblogs.com/GGGG-XXXX/articles/10123471.html)
-   [三方服务之保利威视频播放](https://www.cnblogs.com/GGGG-XXXX/articles/10131342.html)
-   三方服务之滑动验证码



# [跨域](https://www.cnblogs.com/GGGG-XXXX/articles/9893381.html)

## CORS跨域请求

CORS即Cross Origin Resource Sharing 跨域资源共享，

那么跨域请求还分为两种，一种叫简单请求，一种是复杂请求~~

### 简单请求

HTTP方法是下列方法之一

　　HEAD， GET，POST

HTTP头信息不超出以下几种字段

　　Accept， Accept-Language， Content-Language， Last-Event-ID

　　Content-Type只能是下列类型中的一个

　　　　application/x-www-from-urlencoded

　　　　multipart/form-data

　　　　text/plain

任何一个不满足上述要求的请求，即会被认为是复杂请求~~

复杂请求会先发出一个预请求，我们也叫预检，OPTIONS请求~~

### 浏览器的同源策略

跨域是因为浏览器的同源策略导致的，也就是说浏览器会阻止非同源的请求~

那什么是非同源呢即域名不同，端口不同,协议不同都属于非同源的~~~

浏览器只阻止表单以及ajax请求，并不会阻止src请求，所以我们的cnd，图片等src请求都可以发~~

### 解决跨域

#### JSONP

jsonp的实现原理是根据浏览器不阻止src请求入手~来实现的~~



JsonP实现的后端代码

```
class Test(APIView):

    def get(self, request):
        callback = request.query_params.get("callback", "")
        ret = callback + "(" + "'success'" + ")"
        return HttpResponse(ret)
```

[![复制代码](assets/copycode-20220219212440208.gif)](javascript:void(0);)



JsonP测试前端代码

```
<button id="btn_one">点击我向JsonP1发送请求</button>
<script>
    // 测试发送请求失败 跨域不能得到数据
    $('#btn_one').click(function () {
        $.ajax({
            url: "http://127.0.0.1:8000/jsonp1",
            type: "get",
            success: function (response) {
                console.log(response)
            }
        })
    });
    
    function handlerResponse(response) {
        alert(response)
    };
    
    window.onload = function () {
        $("#btn_one").click(function () {
            let script_ele = document.createElement("script");
            script_ele.src = "http://127.0.0.1:8000/jsonp1?callback=handlerResponse";
            document.body.insertBefore(script_ele, document.body.firstChild);
        })
    }


</script>
```

[![复制代码](assets/copycode-20220219212440208.gif)](javascript:void(0);)

JsonP解决跨域只能发送get请求，并且实现起来需要前后端交互比较多。

#### 添加响应头



中间件加响应头

```
from django.utils.deprecation import MiddlewareMixin


class MyCors(MiddlewareMixin):
    def process_response(self, request, response):
        response["Access-Control-Allow-Origin"] = "*"
        if request.method == "OPTIONS":
            response["Access-Control-Allow-Headers"] = "Content-Type"
            response["Access-Control-Allow-Methods"] = "DELETE, PUT, POST"
        return response
```



# [Django ContentType组件](https://www.cnblogs.com/GGGG-XXXX/articles/9697458.html)

### 需求

现在我们有这样一个需求~我们的商城里有很多的商品~~节日要来了~我们要搞活动~~

那么我们就要设计优惠券~~优惠券都有什么类型呢~~满减的~折扣的~立减的~~

我们对应着我们活动类型~对我们的某类商品设计优惠券~~比如~~

家电是一类商品~~食物是一类商品~那么我们可以设计家电折扣优惠券~~以及食物满减优惠券等~

那么我们看表结构怎么设计~~

```python
# by gaoxin
from django.db import models
 
 
class Appliance(models.Model):
    """
    家用电器表
    id name
    1   冰箱
    2   电视
    3   洗衣机
    """
    name = models.CharField(max_length=64)
 
 
class Food(models.Model):
    """
    食物表
    id name
    1  面包
    2  牛奶
    """
    name = models.CharField(max_length=32)
 
 
class Fruit(models.Model):
    """
    水果表
    id  name
    1   苹果
    2   香蕉
    """
    name = models.CharField(max_length=32)
 
 
class Coupon(models.Model):
    """
    优惠券表
    id  name    appliance_id    food_id     fruit_id
    1   通用优惠券   null            null        null
    2   冰箱折扣券   1               null        null
    3   电视折扣券   2               null        null
    4   苹果满减卷   null            null        1
    我每增加一张表就要多增加一个字段
    """
    name = models.CharField(max_length=32)
    appliance = models.ForeignKey(to="Appliance", null=True, blank=True)
    food = models.ForeignKey(to="Food", null=True, blank=True)
    fruit = models.ForeignKey(to="Fruit", null=True, blank=True)<br># 实际上我们商品的种类会特别的多，导致我们这张表外键越来越多
    
    
```

遇到这种一张表要跟多张表进行外键关联的时候~我们Django提供了ContentType组件~

### ContentType组件

ContentType是Django的内置的一个应用，可以追踪项目中所有的APP和model的对应关系，并记录在ContentType表中。

当我们的项目做数据迁移后，会有很多django自带的表，其中就有django_content_type表，我们可以去看下~~~

 

ContentType组件应用：

　　-- 在model中定义ForeignKey字段，并关联到ContentType表，通常这个字段命名为content-type

　　-- 在model中定义PositiveIntergerField字段, 用来存储关联表中的主键，通常我们用object_id

　　-- 在model中定义GenericForeignKey字段，传入上面两个字段的名字

　　-- 方便反向查询可以定义GenericRelation字段

代码如下：

　　

```python
# by gaoxin
from django.db import models
from django.contrib.contenttypes.models import ContentType
from django.contrib.contenttypes.fields import GenericForeignKey, GenericRelation
 
 
class Appliance(models.Model):
    """
    家用电器表
    id name
    1   冰箱
    2   电视
    3   洗衣机
    """
    name = models.CharField(max_length=64)
    coupons = GenericRelation(to="Coupon")
 
 
class Food(models.Model):
    """
    食物表
    id name
    1  面包
    2  牛奶
    """
    name = models.CharField(max_length=32)
 
 
class Fruit(models.Model):
    """
    水果表
    id  name
    1   苹果
    2   香蕉
    """
    name = models.CharField(max_length=32)
 
 
class Coupon(models.Model):
    """
    优惠券表
    id  name    appliance_id    food_id     fruit_id
    1   通用优惠券   null            null        null
    2   冰箱折扣券   1               null        null
    3   电视折扣券   2               null        null
    4   苹果满减卷   null            null        1
    我每增加一张表就要多增加一个字段
    """
    name = models.CharField(max_length=32)
    # appliance = models.ForeignKey(to="Appliance", null=True, blank=True)
    # food = models.ForeignKey(to="Food", null=True, blank=True)
    # fruit = models.ForeignKey(to="Fruit", null=True, blank=True)
    # 第一步
    content_type = models.ForeignKey(to=ContentType)
    # 第二步
    object_id = models.PositiveIntegerField()
    # 第三步
    content_object = GenericForeignKey('content_type', 'object_id')　　
```

数据迁移后~添加数据~我们看下增删改查的操作~~

基本的使用~

```python
from django.http import HttpResponse
from rest_framework.views import APIView
from rest_framework.response import Response
from django.contrib.contenttypes.models import ContentType
from .models import Appliance, Coupon
 
# Create your views here.
 
 
class Test(APIView):
 
    def get(self, request):
        # 通过ContentType获得表名
        content = ContentType.objects.filter(app_label="app01", model="appliance").first()
        # 获得表model对象 相当于models.Applicance
        model_class = content.model_class()
        ret = model_class.objects.all()
 
        # 为海尔冰箱创建一条优惠记录
        ice_box = Appliance.objects.filter(id=1).first()
        Coupon.objects.create(name="海尔冰箱折扣券", content_object=ice_box)
 
        # 查询优惠券id=1绑定了哪个商品
        coupon_obj = Coupon.objects.filter(id=1).first()
        goods_obj = coupon_obj.content_object
        print(goods_obj.name)
 
        # 查询海尔冰箱的所有优惠券 id=1
        # 我们定义了反向查询
        results = ice_box.coupons.all()
        print(results[0].name)
 
        # 如果没定义反向查询
        content = ContentType.objects.filter(app_label="app01", model="appliance").first()
        result = Coupon.objects.filter(content_type=content, object_id=1).all()
        print(result[0].name)
        return HttpResponse(ret)

```

　　



# [项目课程模块](https://www.cnblogs.com/GGGG-XXXX/articles/9913643.html)

## 课程模块

我们要开始写课程模块了~~课程模块都有哪些功能呢~~

我们的课程模块，包括了免费课程以及专题课程两个方向~~

主要是课程的展示，点击课程进入课程详细页面~~

课程详细页面展示，课程的概述，课程的价格策略，课程章节，评价以及常见问题~~

以及一些周边的字段~~~这是主线路~~

### 根据功能设计表结构

对照着对标路飞网站，我们可以先讨论下表结构~~

我们初步能够确定下来12张表~~



课程模块表结构

```python
from django.db import models
from django.contrib.contenttypes.fields import GenericForeignKey, GenericRelation
from django.contrib.contenttypes.models import ContentType

# Create your models here.
__all__ = ["Category", "Course", "CourseDetail", "Teacher", "DegreeCourse", "CourseChapter",
           "CourseSection", "PricePolicy", "OftenAskedQuestion", "Comment", "Account", "CourseOutline"]


class Category(models.Model):
    """课程分类表"""
    title = models.CharField(max_length=32, unique=True, verbose_name="课程的分类")

    def __str__(self):
        return self.title

    class Meta:
        verbose_name = "01-课程分类表"
        db_table = verbose_name
        verbose_name_plural = verbose_name


class Course(models.Model):
    """课程表"""
    title = models.CharField(max_length=128, unique=True, verbose_name="课程的名称")
    course_img = models.ImageField(upload_to="course/%Y-%m", verbose_name='课程的图片')
    category = models.ForeignKey(to="Category", verbose_name="课程的分类")
    COURSE_TYPE_CHOICES = ((0, "付费"), (1, "vip专享"), (2, "学位课程"))
    course_type = models.SmallIntegerField(choices=COURSE_TYPE_CHOICES)
    degree_course = models.ForeignKey(to="DegreeCourse", blank=True, null=True, help_text="如果是学位课程，必须关联学位表")

    brief = models.CharField(verbose_name="课程简介", max_length=1024)
    level_choices = ((0, '初级'), (1, '中级'), (2, '高级'))
    level = models.SmallIntegerField(choices=level_choices, default=1)
    status_choices = ((0, '上线'), (1, '下线'), (2, '预上线'))
    status = models.SmallIntegerField(choices=status_choices, default=0)
    pub_date = models.DateField(verbose_name="发布日期", blank=True, null=True)
    order = models.IntegerField("课程顺序", help_text="从上一个课程数字往后排")
    study_num = models.IntegerField(verbose_name="学习人数", help_text="只要有人买课程，订单表加入数据的同时给这个字段+1")

    # order_details = GenericRelation("OrderDetail", related_query_name="course")
    # coupon = GenericRelation("Coupon")
    # 只用于反向查询不生成字段
    price_policy = GenericRelation("PricePolicy")
    often_ask_questions = GenericRelation("OftenAskedQuestion")
    course_comments = GenericRelation("Comment")

    def save(self, *args, **kwargs):
        if self.course_type == 2:
            if not self.degree_course:
                raise ValueError("学位课必须关联学位课程表")
        super(Course, self).save(*args, **kwargs)

    def __str__(self):
        return self.title

    class Meta:
        verbose_name = "02-课程表"
        db_table = verbose_name
        verbose_name_plural = verbose_name


class CourseDetail(models.Model):
    """课程详细表"""
    course = models.OneToOneField(to="Course")
    hours = models.IntegerField(verbose_name="课时", default=7)
    course_slogan = models.CharField(max_length=125, blank=True, null=True, verbose_name="课程口号")
    video_brief_link = models.CharField(max_length=255, blank=True, null=True)
    summary = models.TextField(max_length=2048, verbose_name="课程概述")
    why_study = models.TextField(verbose_name="为什么学习这门课程")
    what_to_study_brief = models.TextField(verbose_name="我将学到哪些内容")
    career_improvement = models.TextField(verbose_name="此项目如何有助于我的职业生涯")
    prerequisite = models.TextField(verbose_name="课程先修要求", max_length=1024)
    recommend_courses = models.ManyToManyField("Course", related_name="recommend_by", blank=True)
    teachers = models.ManyToManyField("Teacher", verbose_name="课程讲师")

    def __str__(self):
        return self.course.title

    class Meta:
        verbose_name = "03-课程详细表"
        db_table = verbose_name
        verbose_name_plural = verbose_name


class Teacher(models.Model):
    """讲师表"""
    name = models.CharField(max_length=32, verbose_name="讲师名字")
    brief = models.TextField(max_length=1024, verbose_name="讲师介绍")

    def __str__(self):
        return self.name

    class Meta:
        verbose_name = "04-教师表"
        db_table = verbose_name
        verbose_name_plural = verbose_name


class DegreeCourse(models.Model):
    """
    字段大体跟课程表相同，哪些不同根据业务逻辑去区分
    """
    title = models.CharField(max_length=32, verbose_name="学位课程名字")

    def __str__(self):
        return self.title

    class Meta:
        verbose_name = "05-学位课程表"
        db_table = verbose_name
        verbose_name_plural = verbose_name


class CourseChapter(models.Model):
    """课程章节表"""
    course = models.ForeignKey(to="Course", related_name="course_chapters")
    chapter = models.SmallIntegerField(default=1, verbose_name="第几章")
    title = models.CharField(max_length=32, verbose_name="课程章节名称")

    def __str__(self):
        return self.title

    class Meta:
        verbose_name = "06-课程章节表"
        db_table = verbose_name
        verbose_name_plural = verbose_name
        unique_together = ("course", "chapter")


class CourseSection(models.Model):
    """课时表"""
    chapter = models.ForeignKey(to="CourseChapter", related_name="course_sections")
    title = models.CharField(max_length=32, verbose_name="课时")
    section_order = models.SmallIntegerField(verbose_name="课时排序", help_text="建议每个课时之间空1至2个值，以备后续插入课时")
    section_type_choices = ((0, '文档'), (1, '练习'), (2, '视频'))
    free_trail = models.BooleanField("是否可试看", default=False)
    section_type = models.SmallIntegerField(default=2, choices=section_type_choices)
    section_link = models.CharField(max_length=255, blank=True, null=True, help_text="若是video，填vid,若是文档，填link")

    def course_chapter(self):
        return self.chapter.chapter

    def course_name(self):
        return self.chapter.course.title

    def __str__(self):
        return "%s-%s" % (self.chapter, self.title)

    class Meta:
        verbose_name = "07-课程课时表"
        db_table = verbose_name
        verbose_name_plural = verbose_name
        unique_together = ('chapter', 'section_link')


class PricePolicy(models.Model):
    """价格策略表"""
    content_type = models.ForeignKey(ContentType)  # 关联course or degree_course
    object_id = models.PositiveIntegerField()
    content_object = GenericForeignKey('content_type', 'object_id')

    valid_period_choices = ((1, '1天'), (3, '3天'),
                            (7, '1周'), (14, '2周'),
                            (30, '1个月'),
                            (60, '2个月'),
                            (90, '3个月'),
                            (120, '4个月'),
                            (180, '6个月'), (210, '12个月'),
                            (540, '18个月'), (720, '24个月'),
                            (722, '24个月'), (723, '24个月'),
                            )
    valid_period = models.SmallIntegerField(choices=valid_period_choices)
    price = models.FloatField()

    def __str__(self):
        return "%s(%s)%s" % (self.content_object, self.get_valid_period_display(), self.price)

    class Meta:
        verbose_name = "08-价格策略表"
        db_table = verbose_name
        verbose_name_plural = verbose_name
        unique_together = ("content_type", 'object_id', "valid_period")


class OftenAskedQuestion(models.Model):
    """常见问题"""
    content_type = models.ForeignKey(ContentType)  # 关联course or degree_course
    object_id = models.PositiveIntegerField()
    content_object = GenericForeignKey('content_type', 'object_id')

    question = models.CharField(max_length=255)
    answer = models.TextField(max_length=1024)

    def __str__(self):
        return "%s-%s" % (self.content_object, self.question)

    class Meta:
        verbose_name = "09-常见问题表"
        db_table = verbose_name
        verbose_name_plural = verbose_name
        unique_together = ('content_type', 'object_id', 'question')


class Comment(models.Model):
    """通用的评论表"""
    content_type = models.ForeignKey(ContentType, blank=True, null=True)
    object_id = models.PositiveIntegerField(blank=True, null=True)
    content_object = GenericForeignKey('content_type', 'object_id')

    content = models.TextField(max_length=1024, verbose_name="评论内容")
    account = models.ForeignKey("Account", verbose_name="会员名")
    date = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return self.content

    class Meta:
        verbose_name = "10-评价表"
        db_table = verbose_name
        verbose_name_plural = verbose_name


class Account(models.Model):
    username = models.CharField(max_length=32, verbose_name="用户姓名")
    # head_img = models.CharField(max_length=256, default='/static/frontend/head_portrait/logo@2x.png',
    #                             verbose_name="个人头像")

    def __str__(self):
        return self.username

    class Meta:
        verbose_name = "11-用户表"
        db_table = verbose_name
        verbose_name_plural = verbose_name


class CourseOutline(models.Model):
    """课程大纲"""
    course_detail = models.ForeignKey(to="CourseDetail", related_name="course_outline")
    title = models.CharField(max_length=128)
    order = models.PositiveSmallIntegerField(default=1)
    # 前端显示顺序

    content = models.TextField("内容", max_length=2048)

    def __str__(self):
        return "%s" % self.title

    class Meta:
        verbose_name = "12-课程大纲表"
        db_table = verbose_name
        verbose_name_plural = verbose_name
        unique_together = ('course_detail', 'title')
```



### 接口的编写

我们表结构定下来以后，可以根据业务场景看需要哪些接口~~~

对于我们课程这个模块，所有的功能都是展示，基于数据展示的，我们通常称为数据接口~~

这种接口对于我们来说是最简单的~~因为我们只是从数据库拿数据~然后进行展示~~

我们来看下都需要哪些接口~~~

　　-- 课程页面 有课程所有分类这个接口

　　-- 课程页面 有展示课程的接口

　　-- 点击课程进入课程详情页面，详情页面的数据接口~~

　　-- 详情页面下的子路由对应子组件的数据接口

　　　　-- 课程章节课时

　　　　-- 课程的评论

　　　　-- 课程的常见问题

这些所有的数据接口~~套路都是读取数据库，序列化数据，返回~~~

那主要就是用DRF的序列化组件~~那我们从路由~然后序列化组件~然后看视图~~



urls.py

```python
# by gaoxin
from django.conf.urls import url, include
from .views import CourseListView, CourseCategoryView, CourseDetailView, CourseChapterView
from .views import CourseCommentView, OftenAskedQuestionView

# 在项目路由下做了一层分发
# url(r'^api/course/', include("course.urls")),
urlpatterns = [
    url(r"^$", CourseListView.as_view()),
    url(r"^category$", CourseCategoryView.as_view()),
    url(r"^detail/(?P<pk>\d+)$", CourseDetailView.as_view()),
    url(r"^(?P<pk>\d+)/chapters$", CourseChapterView.as_view()),
    url(r"^(?P<pk>\d+)/comment$", CourseCommentView.as_view()),
    url(r"^(?P<pk>\d+)/often-asked-question$", OftenAskedQuestionView.as_view()),
]
```





serializers.py

```
# by gaoxin
from rest_framework import serializers
from .models import Course, Category, CourseDetail, CourseChapter, Comment, OftenAskedQuestion


class CourseSerializer(serializers.ModelSerializer):
    level = serializers.CharField(source="get_level_display")
    price_policy = serializers.SerializerMethodField()

    def get_price_policy(self, obj):
        price_obj = obj.price_policy.all().order_by("price").first()
        return price_obj.price

    class Meta:
        model = Course
        fields = ["id", "title", "brief", "course_img", "study_num", "level", "price_policy"]


class CourseCategorySerializer(serializers.ModelSerializer):
    class Meta:
        model = Category
        fields = ["id", "title"]


class CourseDetailSerializer(serializers.ModelSerializer):
    level = serializers.CharField(source="course.get_level_display")
    study_num = serializers.IntegerField(source="course.study_num")
    price_policy = serializers.SerializerMethodField()
    course_outline = serializers.SerializerMethodField()
    recommend_courses = serializers.SerializerMethodField()
    teachers = serializers.SerializerMethodField()

    def get_teachers(self, obj):
        return [{"id":item.id, "name": item.name} for item in obj.teachers.all()]

    def get_recommend_courses(self, obj):
        return [{"id": item.id, "title": item.title} for item in obj.recommend_courses.all()]

    def get_course_outline(self, obj):
        outlines = obj.course_outline.all().order_by("order")
        return [{"title":outline.title, "content": outline.content} for outline in outlines]

    def get_price_policy(self, obj):
        return [{"id": price_obj.id, "valid_price_display": price_obj.get_valid_period_display(), "price": price_obj.price} for price_obj in obj.course.price_policy.all()]

    class Meta:
        model = CourseDetail
        fields = ["id", "summary", "hours", "level", "study_num", "price_policy", "why_study",
                  "what_to_study_brief", "course_outline", "career_improvement", "prerequisite",
                  "recommend_courses", "teachers"]


class CourseChapterSerializer(serializers.ModelSerializer):
    sections = serializers.SerializerMethodField()

    def get_sections(self, obj):
        sections = obj.course_sections.all().order_by("section_order")
        return [{"id": section.id, "title": section.title, "free_trail": section.free_trail} for section in sections]

    class Meta:
        model = CourseChapter
        fields = ["id", "title", "sections"]


class CourseCommentSerializer(serializers.ModelSerializer):
    account = serializers.CharField(source="account.username")

    class Meta:
        model = Comment
        fields = ["id", "account", "content", "date"]


class OftenAskQuestionSerializer(serializers.ModelSerializer):

    class Meta:
        model = OftenAskedQuestion
        fields = ["id", "question", "answer"]
```





Views.py

```
class CourseCategoryView(APIView):
    """课程分类接口"""

    def get(self, request):
        queryset = Category.objects.all()
        ser_obj = CourseCategorySerializer(queryset, many=True)
        return Response(ser_obj.data)


class CourseListView(APIView):
    """查看所有免费课程的接口"""
    def get(self, request):
        category_id = request.query_params.get("category", 0)
        if category_id == 0:
            # 证明没有分类，可以拿所有的课程数据
            queryset = Course.objects.all().order_by("order")
        else:
            queryset = Course.objects.filter(category_id=category_id).order_by("order")
        ser_obj = CourseSerializer(queryset, many=True)
        return Response(ser_obj.data)


class CourseDetailView(APIView):
    """课程详情页面"""
    def get(self, request, pk):
        course_detail_obj = CourseDetail.objects.filter(course__id=pk).first()
        if course_detail_obj:
            ser_obj = CourseDetailSerializer(course_detail_obj)
            return Response(ser_obj.data)
        else:
            return Response({"code": "1001", "msg": "查询的课程不存在"})


class CourseChapterView(APIView):
    """课程章节接口"""
    def get(self, request, pk):
        # 首先我们要清楚数据结构
        # 我们要的是[章节一：{课时，课时2}]
        queryset = CourseChapter.objects.filter(course_id=pk).order_by("chapter")
        ser_obj = CourseChapterSerializer(queryset, many=True)
        return Response(ser_obj.data)


class CourseCommentView(APIView):
    def get(self, request, pk):
        queryset = Course.objects.filter(pk=pk).first().course_comments.all()
        ser_obj = CourseCommentSerializer(queryset, many=True)
        return Response(ser_obj.data)


class OftenAskedQuestionView(APIView):
    def get(self, request, pk):
        queryset = Course.objects.filter(pk=pk).first().often_ask_questions.all()
        ser_obj = OftenAskQuestionSerializer(queryset, many=True)
        return Response(ser_obj.data)
```



我们的课程的视图还可以重写编写一下~~利用我们之前学的视图的封装的那些类~~



升级版视图的示例

```
class CourseCategoryView(generics.ListAPIView):
    queryset = Category.objects.all()
    serializer_class = CourseCategorySerializer
    """课程分类接口"""

    # def get(self, request):
    #     queryset = Category.objects.all()
    #     ser_obj = CourseCategorySerializer(queryset, many=True)
    #     return Response(ser_obj.data)


class CourseChapterView(generics.RetrieveAPIView):
    queryset = CourseChapter.objects.all()
    serializer_class = CourseChapterSerializer
    # 指定过滤的类 用排序的过滤类
    filter_backends = (filters.OrderingFilter,)
    # 排序的字段
    ordering = ("chapter",)

    # def get(self, request, pk):
    #     # 首先我们要清楚数据结构
    #     # 我们要的是[章节一：{课时，课时2}]
    #     queryset = CourseChapter.objects.filter(course_id=pk).order_by("chapter")
    #     ser_obj = CourseChapterSerializer(queryset, many=True)
    #     return Response(ser_obj.data)
```



我们可以根据上面的更改的视图的示例~~来更改我们所有的视图~~小伙伴们~自己动起手来吧~~

我们课程这个模块下的数据接口我们就介绍这些~~

我们这里涉及课程图片~~用我们Django的mediaURL~~

### Django的MEDIA配置



```
# settings.py

STATIC_URL = '/static/'
# Media配置
MEDIA_URL = "media/"
MEDIA_ROOT = os.path.join(BASE_DIR, "media")
```





```
# urls.py

from django.conf.urls import url, include
from django.contrib import admin
from django.views.static import serve
from new_luffy import settings


urlpatterns = [
    url(r'^admin/', admin.site.urls),
    url(r'^api/course/', include("course.urls")),

    # media路径配置
    url(r'media/(?P<path>.*)$', serve, {'document_root': settings.MEDIA_ROOT})
]
```



这样我们上传的图片~数据库存的是路径地址我们前端向后端的media路径发送请求~~

拿到我们想要的图片，视频等资源~~



# [登录模块](https://www.cnblogs.com/GGGG-XXXX/articles/9922552.html)

### 认证

任何的项目都需要认证，用户输入了用户名和密码，验证通过，代表用户登录成功~~~

那HTTP请求是无状态的，下次这个用户再请求，我们是不可能识别这个用户是否登录的~~

所以我们就要有自己的方式来实现这个认证，也就是说~用户登录成功以后~~~我们给他们

生成一个随机字符串~~以后这个用户再请求~~都要携带这个随机字符串~~

我们就可以根据这个字符串进行判断这个用户是否登录~~~~

那么大家想一个问题~~就是我们给登录的用户生成的随机字符串放在哪里呢~~~

我们放哪里都可以~~目的是前端发送请求的时候带过来就可以了~~~

以前的cookie，session是我们的一种解决方案~~我们讲认证的时候也用过token的这种解决方案~~

### TOKEN

用户登录成功后，生成一个随机字符串token给前端返回~~~

那么前端以后都携带这个token来访问~~这样我们只需要鉴别这个token~来做认证~~

前端如果发送请求~把token放在请求头中~~我们看下我们的认证要怎么写~~

在写认证之前，我们先把登录注册功能写了~~~

 models.py 扩展之前功能模块的用户表

```
# 我们要拓展之前课程模块下的用户表
class Account(models.Model):
    username = models.CharField(max_length=32, verbose_name="用户姓名", unique=True)
    password = models.CharField(max_length=32, verbose_name="用户密码")
    # head_img = models.CharField(max_length=256, default='/static/frontend/head_portrait/logo@2x.png',
    #                             verbose_name="个人头像")
    token = models.UUIDField(null=True, blank=True)

    def __str__(self):
        return self.username

    class Meta:
        verbose_name = "11-用户表"
        db_table = verbose_name
        verbose_name_plural = verbose_name


```



 views.py 编写登录注册视图

```python
# 创建两个视图 一个注册的 一个登录的
from django.shortcuts import render
from rest_framework.views import APIView
from rest_framework.response import Response
from utils.base_response import BaseResponse
from .serializers import UserSerializer
from course.models import Account
import uuid
# Create your views here.


class UserView(APIView):

    # 注册用户
    def post(self, request):
        res = BaseResponse()
        ser_obj = UserSerializer(data=request.data)
        if ser_obj.is_valid():
            ser_obj.save()
            res.data = ser_obj.validated_data
        else:
            res.code = 1010
            res.data = ser_obj.errors
        return Response(res.dict)


class LoginView(APIView):

    # 登录视图
    def post(self, request):
        res = BaseResponse()
        # 这里要获取我们的用户名密码 进行验证是否有这个用户
        # 而且我们这个密码前端一定是密文传过来 我们通过密文对比进行验证
        username = request.data.get("username", "")
        password = request.data.get("password", "")
        user_obj_queryset = Account.objects.filter(username=username, password=password)
        if not user_obj_queryset:
            res.code = 1003
            res.error = "用户名或密码错误"
        try:
            token = uuid.uuid4()
            user_obj_queryset.update(token=token)
            res.data = token
        except Exception as e:
            res.code = 1004
            res.error = "生成token失败"
        return Response(res.dict)


```



 utils.base_response.py

```
# 给前端返回时候用的基础的Response类
class BaseResponse(object):

    def __init__(self):
        self.code = 1000
        self.error = None
        self.data = None

    @property
    def dict(self):
        return self.__dict__


```



 serializers.py 注册序列化器

```
# by gaoxin
from rest_framework import serializers
from course.models import Account
import hashlib

# 我们测试的时候用的重写create方法
# 真正开发前端传过来的就是加密后的密文密码
class UserSerializer(serializers.ModelSerializer):
    class Meta:
        model = Account
        fields = "__all__"

    def create(self, validated_data):
        password = validated_data["password"]
        password_salt = password + "luffy_password"
        md5_str = hashlib.md5(password_salt.encode()).hexdigest()
        user_obj = Account.objects.create(username=validated_data["username"], password=md5_str)
        return user_obj


```



我们的登录注册写完后~~开始写认证~~

 utils.auth.py

```python
# by gaoxin
from rest_framework.authentication import BaseAuthentication
from rest_framework.exceptions import AuthenticationFailed
from course.models import Account
# django 提供的拿时间的接口 提供的是根据django配置的时区拿到的当前时间
from django.utils.timezone import now


class MyAuth(BaseAuthentication):
    def authenticate(self, request):
        if request.method == "OPTIONS":
            return None
        # print(request.META)
        token = request.META.get("HTTP_AUTHENTICATION", "")
        print(token)
        if not token:
            raise AuthenticationFailed({"code": 1021, "error": "缺少token"})
        user_obj = Account.objects.filter(token=token).first()
        if not user_obj:
            raise AuthenticationFailed({"code": 1020, "error": "无效的token"})
        else:
            old_time = user_obj.create_token_time
            if (now() - old_time).days > 7:
                raise AuthenticationFailed({"code": 1020, "error": "无效的token"})
            return user_obj, token


```



 views.py 测试用的视图

```
# 查看购物车是需要登录后才可以
# 所有这是一个需要认证的接口
class ShoppingCarView(APIView):
    authentication_classes = [MyAuth, ]
    # 展示购物车数据
    def get(self, request, *args, **kwargs):
        print(request.user)
        return Response("test")


```

我们基于请求头的token认证就完成了~~~ 

